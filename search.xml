<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>性能优化实验</title>
      <link href="/2022/04/09/xing-neng-you-hua-shi-yan/"/>
      <url>/2022/04/09/xing-neng-you-hua-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化实验"><a href="#性能优化实验" class="headerlink" title="性能优化实验"></a>性能优化实验</h1><p><em>以下代码只供参考，至于怎样展开，双重循环展开怎么搭配效果会更好，还是需要不断试验。</em></p><h2 id="实验一-poly-c的优化"><a href="#实验一-poly-c的优化" class="headerlink" title="实验一 poly.c的优化"></a>实验一 poly.c的优化</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><strong>1、常系数 const_poly_eval</strong>：不知道该怎么优化，感觉老师给的代码就很不错，直接套用。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int const_poly_eval(int *not_use, int not_use2, int x)&#123;&#x2F;&#x2F;int y &#x3D; x * x;&#x2F;&#x2F;int z &#x3D; y*x;    &#x2F;&#x2F;return 81 + (((y - z) + ((x &lt;&lt; 6) - (x &lt;&lt; 1))) + (((y &lt;&lt; 6) + (y &lt;&lt; 1)) + ((z &lt;&lt; 6) + (z &lt;&lt; 4))));int x64, x16, x2;x64 &#x3D; x &lt;&lt; 6;x16 &#x3D; x &lt;&lt; 4;x2 &#x3D; x &lt;&lt; 1;return 81 + x64 - x2 + (x64 + x2 + x + (x64 + x16 - x) * x) * x;&#125;</code></pre><p><strong>2、任意的高阶（和10阶） my_poly_eval</strong>：主要考虑循环展开，经过试验，当展开&gt;&#x3D;10时，几乎性能就达到最优了。同时需要单独考虑degree&#x3D;10的情况，为了让计算十阶更快一点，直接全部展开，并减少“昂贵”的乘法的使用。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int my_poly_eval(int *a, int degree, int x)&#123;if (degree &#x3D;&#x3D; 10) &#123;return a[0] + (a[1] + (a[2] + (a[3]+ (a[4]+ (a[5]+ (a[6]+ (a[7]+ (a[8]+ (a[9]+ a[10] * x)*x)*x)*x)*x)*x)*x)*x)*x)*x;&#x2F;&#x2F;return a[0] + a[1] * x + a[2] * xpwr2 + a[3] * xpwr3 + a[4] * xpwr4 + a[5] * xpwr5 + a[6] * xpwr6 + a[7] * xpwr7 + a[8] * xpwr8 + a[9] * xpwr9 + a[10] * xpwr10;&#125;else &#123;int i;&#x2F;&#x2F;int x2 &#x3D; x * x;&#x2F;&#x2F;int x5 &#x3D; x2 * x2 * x;&#x2F;&#x2F;int x11 &#x3D; x5 * x5 * x;int result &#x3D; 0;int xpwr2 &#x3D; x * x;int xpwr3 &#x3D; xpwr2 * x;int xpwr4 &#x3D; xpwr3 * x;int xpwr5 &#x3D; xpwr4 * x;int xpwr6 &#x3D; xpwr5 * x;int xpwr7 &#x3D; xpwr6 * x;int xpwr8 &#x3D; xpwr7 * x;int xpwr9 &#x3D; xpwr8 * x;int xpwr10 &#x3D; xpwr9 * x;int x11 &#x3D; xpwr10 * x;int limit11 &#x3D; degree - 11;int limit5 &#x3D; degree - 5;int cnt &#x3D; 1;for (i &#x3D; 0; i &lt;&#x3D; limit11; i +&#x3D; 11) &#123;result +&#x3D; (a[i] + a[i + 1]*x + a[i + 2] * xpwr2 + a[i + 3] * xpwr3 + a[i + 4] * xpwr4 + a[i + 5] * xpwr5 + a[i + 6] * xpwr6 + a[i + 7] * xpwr7 + a[i + 8] * xpwr8 + a[i + 9] * xpwr9 + a[i + 10] * xpwr10) * cnt;&#x2F;&#x2F;result +&#x3D; (a[i] + (a[i + 1] + (a[i + 2] + (a[i + 3] + (a[i + 4] + (a[i + 5] + (a[i + 6] + (a[i + 7] + (a[i + 8] + (a[i + 9] + a[i + 10] * x) * x) * x) * x) * x) * x) * x) * x) * x) * x) * cnt;cnt *&#x3D; x11;&#125;for (;i &lt;&#x3D; limit5;i +&#x3D; 5) &#123;result +&#x3D; (a[i] + a[i + 1] * x + a[i + 2] * xpwr2 + a[i + 3] * xpwr3 + a[i + 4] * xpwr4) * cnt;&#x2F;&#x2F;result +&#x3D; (a[i] + (a[i + 1] + (a[i + 2] + (a[i + 3] + a[i + 4] * x)*x)*x)*x) * cnt;cnt *&#x3D; xpwr5;&#x2F;&#x2F;cnt *&#x3D; x5;&#125;for (;i &lt;&#x3D; degree;i++) &#123;result +&#x3D; a[i] * cnt;cnt *&#x3D; x;&#125;return result;&#125;&#125;</code></pre><h3 id="结果：（使用的lcc编译器）"><a href="#结果：（使用的lcc编译器）" class="headerlink" title="结果：（使用的lcc编译器）"></a>结果：（使用的lcc编译器）</h3><p><img src="https://img-blog.csdnimg.cn/3d9ec68a334a48caa80e136e037b95df.png"></p><h2 id="实验二-rowcol-c的优化"><a href="#实验二-rowcol-c的优化" class="headerlink" title="实验二 rowcol.c的优化"></a>实验二 rowcol.c的优化</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>1、列求和 my_c_sum</strong>：这个循环展开即可，经过试验，&gt;&#x3D;10时，性能达到最优，直接上代码</p><pre class="language-c++" data-language="c++"><code class="language-c++">void my_c_sum(matrix_t M, vector_t rowsum, vector_t colsum)&#123;int i, j, limitj, limiti;for (i &#x3D; 0;i &lt; N;i++) &#123;colsum[i] &#x3D; 0;&#125;limitj &#x3D; N - 11;      &#x2F;&#x2F;两个实验，经过多次试验发现，展开&gt;&#x3D;10即可达到最高limiti &#x3D; N - 7;for (i &#x3D; 0; i &lt;&#x3D; limiti; i +&#x3D; 7) &#123;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];colsum[j + 1] +&#x3D; M[i][j + 1] + M[i + 1][j + 1] + M[i + 2][j + 1] + M[i + 3][j + 1] + M[i + 4][j + 1] + M[i + 5][j + 1] + M[i + 6][j + 1];&#x2F;&#x2F; + M[i + 7][j+1] + M[i + 8][j+1] + M[i + 9][j+1] + M[i + 10][j+1];colsum[j + 2] +&#x3D; M[i][j + 2] + M[i + 1][j + 2] + M[i + 2][j + 2] + M[i + 3][j + 2] + M[i + 4][j + 2] + M[i + 5][j + 2] + M[i + 6][j + 2];&#x2F;&#x2F; + M[i + 7][j+2] + M[i + 8][j+2] + M[i + 9][j+2] + M[i + 10][j+2];colsum[j + 3] +&#x3D; M[i][j + 3] + M[i + 1][j + 3] + M[i + 2][j + 3] + M[i + 3][j + 3] + M[i + 4][j + 3] + M[i + 5][j + 3] + M[i + 6][j + 3];&#x2F;&#x2F; + M[i + 7][j+3] + M[i + 8][j+3] + M[i + 9][j+3] + M[i + 10][j+3];colsum[j + 4] +&#x3D; M[i][j + 4] + M[i + 1][j + 4] + M[i + 2][j + 4] + M[i + 3][j + 4] + M[i + 4][j + 4] + M[i + 5][j + 4] + M[i + 6][j + 4];&#x2F;&#x2F; + M[i + 7][j+4] + M[i + 8][j+4] + M[i + 9][j+4] + M[i + 10][j+4];colsum[j + 5] +&#x3D; M[i][j + 5] + M[i + 1][j + 5] + M[i + 2][j + 5] + M[i + 3][j + 5] + M[i + 4][j + 5] + M[i + 5][j + 5] + M[i + 6][j + 5];&#x2F;&#x2F; + M[i + 7][j+5] + M[i + 8][j+5] + M[i + 9][j+5] + M[i + 10][j+5];colsum[j + 6] +&#x3D; M[i][j + 6] + M[i + 1][j + 6] + M[i + 2][j + 6] + M[i + 3][j + 6] + M[i + 4][j + 6] + M[i + 5][j + 6] + M[i + 6][j + 6];&#x2F;&#x2F; + M[i + 7][j+6] + M[i + 8][j+6] + M[i + 9][j+6] + M[i + 10][j+6];colsum[j + 7] +&#x3D; M[i][j + 7] + M[i + 1][j + 7] + M[i + 2][j + 7] + M[i + 3][j + 7] + M[i + 4][j + 7] + M[i + 5][j + 7] + M[i + 6][j + 7];&#x2F;&#x2F; + M[i + 7][j + 7] + M[i + 8][j + 7] + M[i + 9][j + 7] + M[i + 10][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8] + M[i + 1][j + 8] + M[i + 2][j + 8] + M[i + 3][j + 8] + M[i + 4][j + 8] + M[i + 5][j + 8] + M[i + 6][j + 8];&#x2F;&#x2F; + M[i + 7][j + 8] + M[i + 8][j + 8] + M[i + 9][j + 8] + M[i + 10][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9] + M[i + 1][j + 9] + M[i + 2][j + 9] + M[i + 3][j + 9] + M[i + 4][j + 9] + M[i + 5][j + 9] + M[i + 6][j + 9];&#x2F;&#x2F; + M[i + 7][j + 9] + M[i + 8][j + 9] + M[i + 9][j + 9] + M[i + 10][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10] + M[i + 1][j + 10] + M[i + 2][j + 10] + M[i + 3][j + 10] + M[i + 4][j + 10] + M[i + 5][j + 10] + M[i + 6][j + 10];&#x2F;&#x2F; + M[i + 7][j + 10] + M[i + 8][j + 10] + M[i + 9][j + 10] + M[i + 10][j + 10];&#125;for (;j &lt; N;j++) &#123;colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];&#125;&#125;for (;i &lt; N;i++) &#123;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;colsum[j] +&#x3D; M[i][j];colsum[j + 1] +&#x3D; M[i][j + 1];colsum[j + 2] +&#x3D; M[i][j + 2];colsum[j + 3] +&#x3D; M[i][j + 3];colsum[j + 4] +&#x3D; M[i][j + 4];colsum[j + 5] +&#x3D; M[i][j + 5];colsum[j + 6] +&#x3D; M[i][j + 6];colsum[j + 7] +&#x3D; M[i][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10];&#125;for (;j &lt; N;j++) &#123;colsum[j] +&#x3D; M[i][j];&#125;&#125;&#125;</code></pre><p><strong>2、行和列求和 my_rc_sum</strong>：这里我采用双重循环展开，但是至于怎么搭配会是最好我不太清楚，这里这是简单做了一些尝试，然后选取了7和11。另外，rowsum这里，我可以采用用一个临时变量来存储值，最后再让<code>rowsum[i] = yyhi</code>，这样减少了内存的调用，更快一点。</p><pre class="language-c++" data-language="c++"><code class="language-c++">void my_rc_sum(matrix_t M, vector_t rowsum, vector_t colsum)&#123;int i, j, limitj, limiti;int yyh0, yyh1, yyh2, yyh3, yyh4, yyh5, yyh6, yyh;for (i &#x3D; 0;i &lt; N;i++) &#123;colsum[i] &#x3D; 0;&#125;limitj &#x3D; N - 11;      &#x2F;&#x2F;经过多次试验发现，展开&gt;&#x3D;10即可达到最高limiti &#x3D; N - 7;for (i &#x3D; 0; i &lt;&#x3D; limiti; i +&#x3D; 7) &#123;yyh0 &#x3D; 0;yyh1 &#x3D; 0;yyh2 &#x3D; 0;yyh3 &#x3D; 0;yyh4 &#x3D; 0;yyh5 &#x3D; 0;yyh6 &#x3D; 0;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;yyh0 +&#x3D; M[i][j] + M[i][j + 1] + M[i][j + 2] + M[i][j + 3] + M[i][j + 4] + M[i][j + 5] + M[i][j + 6] + M[i][j + 7] + M[i][j + 8] + M[i][j + 9] + M[i][j + 10];yyh1 +&#x3D; M[i + 1][j] + M[i + 1][j + 1] + M[i + 1][j + 2] + M[i + 1][j + 3] + M[i + 1][j + 4] + M[i + 1][j + 5] + M[i + 1][j + 6] + M[i + 1][j + 7] + M[i + 1][j + 8] + M[i + 1][j + 9] + M[i + 1][j + 10];yyh2 +&#x3D; M[i + 2][j] + M[i + 2][j + 1] + M[i + 2][j + 2] + M[i + 2][j + 3] + M[i + 2][j + 4] + M[i + 2][j + 5] + M[i + 2][j + 6] + M[i + 2][j + 7] + M[i + 2][j + 8] + M[i + 2][j + 9] + M[i + 2][j + 10];yyh3 +&#x3D; M[i + 3][j] + M[i + 3][j + 1] + M[i + 3][j + 2] + M[i + 3][j + 3] + M[i + 3][j + 4] + M[i + 3][j + 5] + M[i + 3][j + 6] + M[i + 3][j + 7] + M[i + 3][j + 8] + M[i + 3][j + 9] + M[i + 3][j + 10];yyh4 +&#x3D; M[i + 4][j] + M[i + 4][j + 1] + M[i + 4][j + 2] + M[i + 4][j + 3] + M[i + 4][j + 4] + M[i + 4][j + 5] + M[i + 4][j + 6] + M[i + 4][j + 7] + M[i + 4][j + 8] + M[i + 4][j + 9] + M[i + 4][j + 10];yyh5 +&#x3D; M[i + 5][j] + M[i + 5][j + 1] + M[i + 5][j + 2] + M[i + 5][j + 3] + M[i + 5][j + 4] + M[i + 5][j + 5] + M[i + 5][j + 6] + M[i + 5][j + 7] + M[i + 5][j + 8] + M[i + 5][j + 9] + M[i + 5][j + 10];yyh6 +&#x3D; M[i + 6][j] + M[i + 6][j + 1] + M[i + 6][j + 2] + M[i + 6][j + 3] + M[i + 6][j + 4] + M[i + 6][j + 5] + M[i + 6][j + 6] + M[i + 6][j + 7] + M[i + 6][j + 8] + M[i + 6][j + 9] + M[i + 6][j + 10];colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];colsum[j + 1] +&#x3D; M[i][j + 1] + M[i + 1][j + 1] + M[i + 2][j + 1] + M[i + 3][j + 1] + M[i + 4][j + 1] + M[i + 5][j + 1] + M[i + 6][j + 1];&#x2F;&#x2F; + M[i + 7][j+1] + M[i + 8][j+1] + M[i + 9][j+1] + M[i + 10][j+1];colsum[j + 2] +&#x3D; M[i][j + 2] + M[i + 1][j + 2] + M[i + 2][j + 2] + M[i + 3][j + 2] + M[i + 4][j + 2] + M[i + 5][j + 2] + M[i + 6][j + 2];&#x2F;&#x2F; + M[i + 7][j+2] + M[i + 8][j+2] + M[i + 9][j+2] + M[i + 10][j+2];colsum[j + 3] +&#x3D; M[i][j + 3] + M[i + 1][j + 3] + M[i + 2][j + 3] + M[i + 3][j + 3] + M[i + 4][j + 3] + M[i + 5][j + 3] + M[i + 6][j + 3];&#x2F;&#x2F; + M[i + 7][j+3] + M[i + 8][j+3] + M[i + 9][j+3] + M[i + 10][j+3];colsum[j + 4] +&#x3D; M[i][j + 4] + M[i + 1][j + 4] + M[i + 2][j + 4] + M[i + 3][j + 4] + M[i + 4][j + 4] + M[i + 5][j + 4] + M[i + 6][j + 4];&#x2F;&#x2F; + M[i + 7][j+4] + M[i + 8][j+4] + M[i + 9][j+4] + M[i + 10][j+4];colsum[j + 5] +&#x3D; M[i][j + 5] + M[i + 1][j + 5] + M[i + 2][j + 5] + M[i + 3][j + 5] + M[i + 4][j + 5] + M[i + 5][j + 5] + M[i + 6][j + 5];&#x2F;&#x2F; + M[i + 7][j+5] + M[i + 8][j+5] + M[i + 9][j+5] + M[i + 10][j+5];colsum[j + 6] +&#x3D; M[i][j + 6] + M[i + 1][j + 6] + M[i + 2][j + 6] + M[i + 3][j + 6] + M[i + 4][j + 6] + M[i + 5][j + 6] + M[i + 6][j + 6];&#x2F;&#x2F; + M[i + 7][j+6] + M[i + 8][j+6] + M[i + 9][j+6] + M[i + 10][j+6];colsum[j + 7] +&#x3D; M[i][j + 7] + M[i + 1][j + 7] + M[i + 2][j + 7] + M[i + 3][j + 7] + M[i + 4][j + 7] + M[i + 5][j + 7] + M[i + 6][j + 7];&#x2F;&#x2F; + M[i + 7][j + 7] + M[i + 8][j + 7] + M[i + 9][j + 7] + M[i + 10][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8] + M[i + 1][j + 8] + M[i + 2][j + 8] + M[i + 3][j + 8] + M[i + 4][j + 8] + M[i + 5][j + 8] + M[i + 6][j + 8];&#x2F;&#x2F; + M[i + 7][j + 8] + M[i + 8][j + 8] + M[i + 9][j + 8] + M[i + 10][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9] + M[i + 1][j + 9] + M[i + 2][j + 9] + M[i + 3][j + 9] + M[i + 4][j + 9] + M[i + 5][j + 9] + M[i + 6][j + 9];&#x2F;&#x2F; + M[i + 7][j + 9] + M[i + 8][j + 9] + M[i + 9][j + 9] + M[i + 10][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10] + M[i + 1][j + 10] + M[i + 2][j + 10] + M[i + 3][j + 10] + M[i + 4][j + 10] + M[i + 5][j + 10] + M[i + 6][j + 10];&#x2F;&#x2F; + M[i + 7][j + 10] + M[i + 8][j + 10] + M[i + 9][j + 10] + M[i + 10][j + 10];&#125;for (;j &lt; N;j++) &#123;yyh0 +&#x3D; M[i][j];yyh1 +&#x3D; M[i + 1][j];yyh2 +&#x3D; M[i + 2][j];yyh3 +&#x3D; M[i + 3][j];yyh4 +&#x3D; M[i + 4][j];yyh5 +&#x3D; M[i + 5][j];yyh6 +&#x3D; M[i + 6][j];colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];&#125;rowsum[i] &#x3D; yyh0;rowsum[i + 1] &#x3D; yyh1;rowsum[i + 2] &#x3D; yyh2;rowsum[i + 3] &#x3D; yyh3;rowsum[i + 4] &#x3D; yyh4;rowsum[i + 5] &#x3D; yyh5;rowsum[i + 6] &#x3D; yyh6;&#125;for (;i &lt; N;i++) &#123;yyh &#x3D; 0;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;yyh +&#x3D; M[i][j] + M[i][j + 1] + M[i][j + 2] + M[i][j + 3] + M[i][j + 4] + M[i][j + 5] + M[i][j + 6] + M[i][j + 7] + M[i][j + 8] + M[i][j + 9] + M[i][j + 10];colsum[j] +&#x3D; M[i][j];colsum[j + 1] +&#x3D; M[i][j + 1];colsum[j + 2] +&#x3D; M[i][j + 2];colsum[j + 3] +&#x3D; M[i][j + 3];colsum[j + 4] +&#x3D; M[i][j + 4];colsum[j + 5] +&#x3D; M[i][j + 5];colsum[j + 6] +&#x3D; M[i][j + 6];colsum[j + 7] +&#x3D; M[i][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10];&#125;for (;j &lt; N;j++) &#123;yyh +&#x3D; M[i][j];colsum[j] +&#x3D; M[i][j];&#125;rowsum[i] &#x3D; yyh;&#125;&#125;</code></pre><h3 id="结果：（使用的lcc编译器）-1"><a href="#结果：（使用的lcc编译器）-1" class="headerlink" title="结果：（使用的lcc编译器）"></a>结果：（使用的lcc编译器）</h3><p><img src="https://img-blog.csdnimg.cn/916e6726a64b4d0db990eb0cad339146.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo初体验</title>
      <link href="/2022/04/02/title1/"/>
      <url>/2022/04/02/title1/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建初体验"><a href="#Hexo搭建初体验" class="headerlink" title="Hexo搭建初体验"></a>Hexo搭建初体验</h1><p>yl告诉我一个小时就能搭完，结果从昨天上午到现在，我才搭建好框架。。。<br>只能说自己菜啊（QAQ），只是发篇文章试一下，我继续去搞背景和图床去了。<br>时隔29个小时，终于搞完了！！！！！<br>去赶ddl咯！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
