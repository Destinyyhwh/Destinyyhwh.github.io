<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cache</title>
      <link href="/2022/05/06/cache/"/>
      <url>/2022/05/06/cache/</url>
      
        <content type="html"><![CDATA[<p>好几个人跟我要过，那就直接发博客里吧。<br>采用的LRU算法。至于更牛的LRU-k算法我没有去写，应该不是很难写，不过需要有额外的数组啊什么的去记录状态信息，而且这好像并不符合老师规定（老师是这么跟我说的，他说不符合规定，不过可以试一下），如果有大佬写了，记得给我看一下。</p><p><strong>以下采用的是LRU算法</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  Copyright 2020 by mars.                                        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;common.h&quot;#define DEBUG0      &#x2F;&#x2F;判断是否出现错误&#x2F;&#x2F; 获得一个数的2的幂次#define GET_POWER_OF_2(X)(X &#x3D;&#x3D; 0x00? 0 : \X &#x3D;&#x3D; 0x01? 0 : \X &#x3D;&#x3D; 0x02? 1 : \X &#x3D;&#x3D; 0x04? 2 : \X &#x3D;&#x3D; 0x08? 3 : \X &#x3D;&#x3D; 0x10? 4 : \X &#x3D;&#x3D; 0x20? 5 : \X &#x3D;&#x3D; 0x40? 6 : \X &#x3D;&#x3D; 0x80? 7 : \X &#x3D;&#x3D; 0x100? 8 : \X &#x3D;&#x3D; 0x200? 9 : \X &#x3D;&#x3D; 0x400? 10 : \X &#x3D;&#x3D; 0x800? 11 : \X &#x3D;&#x3D; 0x1000? 12 : \X &#x3D;&#x3D; 0x2000? 13 : \X &#x3D;&#x3D; 0x4000? 14 : \X &#x3D;&#x3D; 0x8000? 15 : \X &#x3D;&#x3D; 0x10000? 16 : \X &#x3D;&#x3D; 0x20000? 17 : \X &#x3D;&#x3D; 0x40000? 18 : \X &#x3D;&#x3D; 0x80000? 19 : \X &#x3D;&#x3D; 0x100000? 20 : \X &#x3D;&#x3D; 0x200000? 21 : \X &#x3D;&#x3D; 0x400000? 22 : \X &#x3D;&#x3D; 0x800000? 23 : \X &#x3D;&#x3D; 0x1000000? 24 : \X &#x3D;&#x3D; 0x2000000? 25 : \X &#x3D;&#x3D; 0x4000000? 26 : \X &#x3D;&#x3D; 0x8000000? 27 : \X &#x3D;&#x3D; 0x10000000? 28 : \X &#x3D;&#x3D; 0x20000000? 29 : \X &#x3D;&#x3D; 0x40000000? 30 : \X &#x3D;&#x3D; 0x80000000? 31 : \X &#x3D;&#x3D; 0x100000000? 32 : 0)&#x2F;* Cache，16KB大小    2^14*&#x2F;#define DCACHE_SIZE16384&#x2F;&#x2F; 16KB#define DCACHE_DATA_PER_LINE8&#x2F;&#x2F; 块的大小（必须是8字节的倍数）#define DCACHE_DATA_PER_LINE_ADDR_BITSGET_POWER_OF_2(DCACHE_DATA_PER_LINE)&#x2F;&#x2F; 块对应的地址位数#define DE128&#x2F;&#x2F; 每组的行数（2的幂次）#define DCACHE_SET(DCACHE_SIZE&#x2F;DCACHE_DATA_PER_LINE&#x2F;DE)&#x2F;&#x2F; 组数#define DCACHE_SET_ADDR_BITSGET_POWER_OF_2(DCACHE_SET)&#x2F;&#x2F; 组对应的地址位数#define ICACHE_SIZE16384&#x2F;&#x2F; 16KB#define ICACHE_INST_PER_LINE8&#x2F;&#x2F; 块的大小（必须是8字节的倍数）#define ICACHE_INST_PER_LINE_ADDR_BITSGET_POWER_OF_2(ICACHE_INST_PER_LINE)&#x2F;&#x2F; 块对应的地址位数#define IE8&#x2F;&#x2F; 每组的行数（2的幂次）#define ICACHE_SET(ICACHE_SIZE&#x2F;ICACHE_INST_PER_LINE&#x2F;IE)&#x2F;&#x2F; 组数#define ICACHE_SET_ADDR_BITSGET_POWER_OF_2(ICACHE_SET)&#x2F;&#x2F; 组对应的地址位数&#x2F;&#x2F; Cache行的结构，包括Valid、Tag和Data。你所有的状态信息，只能记录在Cache行中！struct DCACHE_LineStruct&#123;UINT32Num;&#x2F;&#x2F;LRU算法UINT8Dirty;&#x2F;&#x2F;是否污染(0污染；1未污染)UINT8Valid;&#x2F;&#x2F;有效位  UINT64Tag;&#x2F;&#x2F;标识位  UINT8Data[DCACHE_DATA_PER_LINE];&#x2F;&#x2F;DCACHE_DATA_PER_LINE个字节&#125;DCache[DCACHE_SET][DE];&#x2F;&#x2F;组数&#x2F;*DCache初始化代码，一般需要把DCache的有效位Valid设置为0模拟器启动时，会调用此InitDataCache函数*&#x2F;void InitDataCache()&#123;UINT32 i;UINT32 j;printf(&quot;[%s] +-----------------------------------+\n&quot;, __func__);printf(&quot;[%s] |   yyh的Data Cache初始化ing.... |\n&quot;, __func__);printf(&quot;[%s] +-----------------------------------+\n&quot;, __func__);for (i &#x3D; 0; i &lt; DCACHE_SET; i++) &#123;    &#x2F;&#x2F;初始化for (j &#x3D; 0;j &lt; DE;j++) &#123;DCache[i][j].Valid &#x3D; 0;DCache[i][j].Dirty &#x3D; 0;DCache[i][j].Num &#x3D; 0;&#125;&#125;&#125;&#x2F;*将Data Cache中的一行数据，写入存储器*&#x2F;void StoreDataCacheLineToMemory(UINT64 Address, UINT32 CacheLineAddress, UINT32 j)&#123;&#x2F;&#x2F; 一次性将DCACHE_DATA_PER_LINE数据从某个Data Cache行写入Memory中&#x2F;&#x2F; 提供了一个函数，一次可以写入8个字节UINT32 i;UINT64 WriteData;UINT64 AlignAddress;UINT64* pp;AlignAddress &#x3D; Address &amp; ~(DCACHE_DATA_PER_LINE - 1);&#x2F;&#x2F; 地址必须对齐到DCACHE_DATA_PER_LINE 字节边界pp &#x3D; (UINT64*)DCache[CacheLineAddress][j].Data;WriteData &#x3D; 0;for (i &#x3D; 0; i &lt; DCACHE_DATA_PER_LINE &#x2F; 8; i++)&#123;WriteData &#x3D; pp[i];WriteMemory(AlignAddress + 8LL * i, WriteData);if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX ReadData&#x3D;%016llX\n&quot;, __func__, AlignAddress + 8LL * i, WriteData);&#125;&#125;&#x2F;*从Memory中读入一行数据到Data Cache中*&#x2F;UINT32 LoadDataCacheLineFromMemory(UINT64 Address, UINT32 CacheLineAddress, UINT64 AddressTag)&#123;&#x2F;&#x2F; 一次性从Memory中将DCACHE_DATA_PER_LINE数据读入某个Data Cache行&#x2F;&#x2F; 提供了一个函数，一次可以读入8个字节UINT32 i;UINT32 j;UINT64 ReadData;     &#x2F;&#x2F;8个字节UINT64 AlignAddress;UINT64* pp;AlignAddress &#x3D; Address &amp; ~(DCACHE_DATA_PER_LINE - 1);&#x2F;&#x2F; 地址必须对齐到DCACHE_DATA_PER_LINE (64)字节边界for (j &#x3D; 0;j &lt; DE;j++) &#123;if (DCache[CacheLineAddress][j].Valid &#x3D;&#x3D; 0) &#123;break;&#125;&#125;if (j &#x3D;&#x3D; DE) &#123;&#x2F;&#x2F;说明所有位都有效，采取LRUUINT32 mx &#x3D; DCache[CacheLineAddress][0].Num;j &#x3D; 0;for (UINT32 temp1 &#x3D; 1; temp1 &lt; DE; temp1++) &#123;    &#x2F;&#x2F;LRUif (DCache[CacheLineAddress][temp1].Num &gt; mx) &#123;mx &#x3D; DCache[CacheLineAddress][temp1].Num;j &#x3D; temp1;&#125;&#125;&#125;if (DCache[CacheLineAddress][j].Dirty &#x3D;&#x3D; 1) &#123;   &#x2F;&#x2F;被污染了UINT64 OldAddress;OldAddress &#x3D; ((DCache[CacheLineAddress][j].Tag &lt;&lt; DCACHE_SET_ADDR_BITS) &lt;&lt; DCACHE_DATA_PER_LINE_ADDR_BITS) | ((UINT64)CacheLineAddress &lt;&lt; DCACHE_DATA_PER_LINE_ADDR_BITS);&#x2F;&#x2F; 从Tag中恢复旧的地址StoreDataCacheLineToMemory(OldAddress, CacheLineAddress, j);&#125;pp &#x3D; (UINT64*)DCache[CacheLineAddress][j].Data;   &#x2F;&#x2F;找到对应的组数、行数for (i &#x3D; 0; i &lt; DCACHE_DATA_PER_LINE &#x2F; 8; i++)&#123;ReadData &#x3D; ReadMemory(AlignAddress + 8LL * i);      &#x2F;&#x2F;读八个字节（从偏移量0开始）if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX ReadData&#x3D;%016llX\n&quot;, __func__, AlignAddress + 8LL * i, ReadData);pp[i] &#x3D; ReadData;&#125;DCache[CacheLineAddress][j].Dirty &#x3D; 0;DCache[CacheLineAddress][j].Valid &#x3D; 1;DCache[CacheLineAddress][j].Tag &#x3D; AddressTag;&#x2F;&#x2F;for (i &#x3D; 0;i &lt; E;i++) &#123;&#x2F;&#x2F;DCache[CacheLineAddress][i].Num++;&#x2F;&#x2F;&#125;DCache[CacheLineAddress][j].Num &#x3D; 0;return j;&#125;&#x2F;*Data Cache访问接口，系统模拟器会调用此接口，来实现对你的Data Cache访问Address:访存字节地址Operation:操作：读操作（&#39;L&#39;）、写操作（&#39;S&#39;）、读-修改-写操作（&#39;M&#39;）DataSize:数据大小：1字节、2字节、4字节、8字节StoreValue:当执行写操作的时候，需要写入的数据LoadResult:当执行读操作的时候，从Cache读出的数据*&#x2F;UINT8 AccessDataCache(UINT64 Address, UINT8 Operation, UINT8 DataSize, UINT64 StoreValue, UINT64* LoadResult)&#123;UINT32 CacheLineAddress;    &#x2F;&#x2F;找对应的组数UINT8 BlockOffset;&#x2F;&#x2F;偏移量UINT64 AddressTag;&#x2F;&#x2F;Tag标记UINT8 MissFlag &#x3D; &#39;M&#39;;&#x2F;&#x2F;是否命中UINT64 ReadValue;UINT32 i;UINT8 Flag &#x3D; 0;*LoadResult &#x3D; 0;UINT32 j;&#x2F;**Address被切分为  AddressTag，CacheLineAddress，BlockOffset*&#x2F;&#x2F;&#x2F; CacheLineAddress Cache的组号（每组E行）CacheLineAddress &#x3D; (Address &gt;&gt; DCACHE_DATA_PER_LINE_ADDR_BITS) % DCACHE_SET;BlockOffset &#x3D; Address % DCACHE_DATA_PER_LINE;AddressTag &#x3D; (Address &gt;&gt; DCACHE_DATA_PER_LINE_ADDR_BITS) &gt;&gt; DCACHE_SET_ADDR_BITS;&#x2F;&#x2F; 地址去掉DCACHE_SET、DCACHE_DATA_PER_LINE，剩下的作为Tag。警告！不能将整个地址作为Tag！！for (i &#x3D; 0;i &lt; DE;i++) &#123;if (DCache[CacheLineAddress][i].Valid &#x3D;&#x3D; 1 &amp;&amp; DCache[CacheLineAddress][i].Tag &#x3D;&#x3D; AddressTag) &#123;Flag &#x3D; 1;break;&#125;&#125;if (Flag &#x3D;&#x3D; 1)&#123;MissFlag &#x3D; &#39;H&#39;;&#x2F;&#x2F; 命中！for (UINT32 temp1 &#x3D; 0; temp1 &lt; DE; temp1++) &#123;    &#x2F;&#x2F;更新DCache[CacheLineAddress][temp1].Num++;&#125;DCache[CacheLineAddress][i].Num &#x3D; 0;if (Operation &#x3D;&#x3D; &#39;L&#39;)&#x2F;&#x2F; 读操作&#123;ReadValue &#x3D; 0;switch (DataSize)&#123;case 1:&#x2F;&#x2F; 1个字节ReadValue &#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 0];break;case 2:&#x2F;&#x2F; 2个字节BlockOffset &#x3D; BlockOffset &amp; 0xFE;&#x2F;&#x2F; 需对齐到2字节边界ReadValue &#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;  &#x2F;&#x2F;小端格式（移8是因为每个字节8位）ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 0];break;case 4:&#x2F;&#x2F; 4个字节BlockOffset &#x3D; BlockOffset &amp; 0xFC;&#x2F;&#x2F; 需对齐到4字节边界ReadValue &#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 3]; ReadValue &#x3D; ReadValue &lt;&lt; 8;   &#x2F;&#x2F;同上ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 2]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 0];break;case 8:&#x2F;&#x2F; 8个字节BlockOffset &#x3D; BlockOffset &amp; 0xF8;&#x2F;&#x2F; 需对齐到8字节边界ReadValue &#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 7]; ReadValue &#x3D; ReadValue &lt;&lt; 8;   &#x2F;&#x2F;同上ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 6]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 5]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 4]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 3]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 2]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; DCache[CacheLineAddress][i].Data[BlockOffset + 0];break;&#125;*LoadResult &#x3D; ReadValue;if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX Operation&#x3D;%c DataSize&#x3D;%u StoreValue&#x3D;%016llX ReadValue&#x3D;%016llX\n&quot;, __func__, Address, Operation, DataSize, StoreValue, ReadValue);&#125;else if (Operation &#x3D;&#x3D; &#39;S&#39; || Operation &#x3D;&#x3D; &#39;M&#39;)&#x2F;&#x2F; 写操作（修改操作在此等价于写操作）&#123;if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX Operation&#x3D;%c DataSize&#x3D;%u StoreValue&#x3D;%016llX\n&quot;, __func__, Address, Operation, DataSize, StoreValue);switch (DataSize)&#123;case 1:&#x2F;&#x2F; 1个字节DCache[CacheLineAddress][i].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF;    &#x2F;&#x2F;8位（1个字节）break;case 2:&#x2F;&#x2F; 2个字节BlockOffset &#x3D; BlockOffset &amp; 0xFE;&#x2F;&#x2F; 需对齐到2字节边界DCache[CacheLineAddress][i].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF;break;case 4:&#x2F;&#x2F; 4个字节BlockOffset &#x3D; BlockOffset &amp; 0xFC;&#x2F;&#x2F; 需对齐到4字节边界DCache[CacheLineAddress][i].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 2] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 3] &#x3D; StoreValue &amp; 0xFF;break;case 8:&#x2F;&#x2F; 8个字节BlockOffset &#x3D; BlockOffset &amp; 0xF8;&#x2F;&#x2F; 需对齐到8字节边界DCache[CacheLineAddress][i].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 2] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 3] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 4] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 5] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 6] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][i].Data[BlockOffset + 7] &#x3D; StoreValue &amp; 0xFF;break;&#125;DCache[CacheLineAddress][i].Dirty &#x3D; 1;     &#x2F;&#x2F;被污染了&#125;&#125;else   &#x2F;&#x2F;不命中（读不命中，写不命中）&#123;if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX Operation&#x3D;%c DataSize&#x3D;%u StoreValue&#x3D;%016llX\n&quot;, __func__, Address, Operation, DataSize, StoreValue);MissFlag &#x3D; &#39;M&#39;;&#x2F;&#x2F; 不命中&#x2F;&#x2F; 需要从Memory中读入新的行（真实情况下，这个LoadCacheLineFromMemory需要很长时间的）j &#x3D; LoadDataCacheLineFromMemory(Address, CacheLineAddress, AddressTag);    &#x2F;&#x2F;把一整行都读进去（不去考虑偏移量这个问题）if (Operation &#x3D;&#x3D; &#39;L&#39;)&#x2F;&#x2F; 读操作&#123;&#x2F;&#x2F; 读操作不需要做事情，因为已经MISS了&#125;else if (Operation &#x3D;&#x3D; &#39;S&#39; || Operation &#x3D;&#x3D; &#39;M&#39;)&#x2F;&#x2F; 写操作（修改操作在此等价于写操作）&#123;&#x2F;&#x2F; 写操作，需要将新的StoreValue更新到CacheLine中switch (DataSize)&#123;case 1:&#x2F;&#x2F; 1个字节DCache[CacheLineAddress][j].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF;break;case 2:&#x2F;&#x2F; 2个字节BlockOffset &#x3D; BlockOffset &amp; 0xFE;&#x2F;&#x2F; 需对齐到2字节边界DCache[CacheLineAddress][j].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF;break;case 4:&#x2F;&#x2F; 4个字节BlockOffset &#x3D; BlockOffset &amp; 0xFC;&#x2F;&#x2F; 需对齐到4字节边界DCache[CacheLineAddress][j].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 2] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 3] &#x3D; StoreValue &amp; 0xFF;break;case 8:&#x2F;&#x2F; 8个字节BlockOffset &#x3D; BlockOffset &amp; 0xF8;&#x2F;&#x2F; 需对齐到8字节边界DCache[CacheLineAddress][j].Data[BlockOffset + 0] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 1] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 2] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 3] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 4] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 5] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 6] &#x3D; StoreValue &amp; 0xFF; StoreValue &#x3D; StoreValue &gt;&gt; 8;DCache[CacheLineAddress][j].Data[BlockOffset + 7] &#x3D; StoreValue &amp; 0xFF;break;&#125;DCache[CacheLineAddress][j].Dirty &#x3D; 1;&#125;&#125;return MissFlag;&#125;&#x2F;&#x2F; Cache行的结构，包括Valid、Tag和Data。你所有的状态信息，只能记录在Cache行中！struct ICACHE_LineStruct&#123;UINT32Num;&#x2F;&#x2F;LRU算法UINT8Valid;&#x2F;&#x2F;有效位  UINT64Tag;&#x2F;&#x2F;标识位  UINT8Inst[ICACHE_INST_PER_LINE];&#x2F;&#x2F;ICACHE_INST_PER_LINE个字节&#125;ICache[ICACHE_SET][IE];&#x2F;&#x2F;组数&#x2F;* 指令Cache实现部分，可选实现 *&#x2F;void InitInstCache(void)&#123;UINT32 i;UINT32 j;printf(&quot;[%s] +-----------------------------------+\n&quot;, __func__);printf(&quot;[%s] |   yyh的Inst Cache初始化ing.... |\n&quot;, __func__);printf(&quot;[%s] +-----------------------------------+\n&quot;, __func__);for (i &#x3D; 0; i &lt; ICACHE_SET; i++) &#123;    &#x2F;&#x2F;初始化for (j &#x3D; 0;j &lt; IE;j++) &#123;ICache[i][j].Valid &#x3D; 0;ICache[i][j].Num &#x3D; 0;&#125;&#125;return;&#125;void LoadInstCacheLineFromMemory(UINT64 Address, UINT32 CacheLineAddress, UINT64 AddressTag)&#123;&#x2F;&#x2F; 一次性从Memory中将DCACHE_DATA_PER_LINE数据读入某个Data Cache行&#x2F;&#x2F; 提供了一个函数，一次可以读入8个字节UINT32 i;UINT32 j;UINT64 ReadInst;     &#x2F;&#x2F;8个字节UINT64 AlignAddress;UINT64* pp;AlignAddress &#x3D; Address &amp; ~(ICACHE_INST_PER_LINE - 1);&#x2F;&#x2F; 地址必须对齐到ICACHE_INST_PER_LINE (64)字节边界for (j &#x3D; 0;j &lt; IE;j++) &#123;if (ICache[CacheLineAddress][j].Valid &#x3D;&#x3D; 0) &#123;break;&#125;&#125;if (j &#x3D;&#x3D; IE) &#123;&#x2F;&#x2F;说明所有位都有效，采取LRUUINT32 mx &#x3D; ICache[CacheLineAddress][0].Num;j &#x3D; 0;for (UINT32 temp1 &#x3D; 1; temp1 &lt; IE; temp1++) &#123;    &#x2F;&#x2F;LRUif (ICache[CacheLineAddress][temp1].Num &gt; mx) &#123;mx &#x3D; ICache[CacheLineAddress][temp1].Num;j &#x3D; temp1;&#125;&#125;&#125;pp &#x3D; (UINT64*)ICache[CacheLineAddress][j].Inst;   &#x2F;&#x2F;找到对应的组数、行数for (i &#x3D; 0; i &lt; ICACHE_INST_PER_LINE &#x2F; 8; i++)&#123;ReadInst &#x3D; ReadMemory(AlignAddress + 8LL * i);      &#x2F;&#x2F;读八个字节（从偏移量0开始）if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX ReadInst&#x3D;%016llX\n&quot;, __func__, AlignAddress + 8LL * i, ReadInst);pp[i] &#x3D; ReadInst;&#125;ICache[CacheLineAddress][j].Valid &#x3D; 1;ICache[CacheLineAddress][j].Tag &#x3D; AddressTag;ICache[CacheLineAddress][j].Num &#x3D; 0;return;&#125;UINT8 AccessInstCache(UINT64 Address, UINT8 Operation, UINT8 InstSize, UINT64* InstResult)&#123;UINT32 CacheLineAddress;    &#x2F;&#x2F;找对应的组数UINT8 BlockOffset;&#x2F;&#x2F;偏移量UINT64 AddressTag;&#x2F;&#x2F;Tag标记UINT8 MissFlag &#x3D; &#39;M&#39;;&#x2F;&#x2F;是否命中UINT64 ReadValue;UINT32 i;UINT8 Flag &#x3D; 0;*InstResult &#x3D; 0;UINT32 j;&#x2F;**Address被切分为  AddressTag，CacheLineAddress，BlockOffset*&#x2F;&#x2F;&#x2F; CacheLineAddress Cache的组号（每组E行）CacheLineAddress &#x3D; (Address &gt;&gt; ICACHE_INST_PER_LINE_ADDR_BITS) % ICACHE_SET;BlockOffset &#x3D; Address % ICACHE_INST_PER_LINE;AddressTag &#x3D; (Address &gt;&gt; ICACHE_INST_PER_LINE_ADDR_BITS) &gt;&gt; ICACHE_SET_ADDR_BITS;&#x2F;&#x2F; 地址去掉DCACHE_SET、DCACHE_DATA_PER_LINE，剩下的作为Tag。警告！不能将整个地址作为Tag！！for (i &#x3D; 0;i &lt; IE;i++) &#123;if (ICache[CacheLineAddress][i].Valid &#x3D;&#x3D; 1 &amp;&amp; ICache[CacheLineAddress][i].Tag &#x3D;&#x3D; AddressTag) &#123;Flag &#x3D; 1;break;&#125;&#125;if (Flag &#x3D;&#x3D; 1)&#123;MissFlag &#x3D; &#39;H&#39;;&#x2F;&#x2F; 命中！for (UINT32 temp1 &#x3D; 0; temp1 &lt; IE; temp1++) &#123;    &#x2F;&#x2F;更新ICache[CacheLineAddress][temp1].Num++;&#125;ICache[CacheLineAddress][i].Num &#x3D; 0;ReadValue &#x3D; 0;switch (InstSize)&#123;case 1:&#x2F;&#x2F; 1个字节ReadValue &#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 0];break;case 2:&#x2F;&#x2F; 2个字节BlockOffset &#x3D; BlockOffset &amp; 0xFE;&#x2F;&#x2F; 需对齐到2字节边界ReadValue &#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;  &#x2F;&#x2F;小端格式（移8是因为每个字节8位）ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 0];break;case 4:&#x2F;&#x2F; 4个字节BlockOffset &#x3D; BlockOffset &amp; 0xFC;&#x2F;&#x2F; 需对齐到4字节边界ReadValue &#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 3]; ReadValue &#x3D; ReadValue &lt;&lt; 8;   &#x2F;&#x2F;同上ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 2]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 0];break;case 8:&#x2F;&#x2F; 8个字节BlockOffset &#x3D; BlockOffset &amp; 0xF8;&#x2F;&#x2F; 需对齐到8字节边界ReadValue &#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 7]; ReadValue &#x3D; ReadValue &lt;&lt; 8;   &#x2F;&#x2F;同上ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 6]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 5]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 4]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 3]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 2]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 1]; ReadValue &#x3D; ReadValue &lt;&lt; 8;ReadValue |&#x3D; ICache[CacheLineAddress][i].Inst[BlockOffset + 0];break;&#125;*InstResult &#x3D; ReadValue;if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX Operation&#x3D;%c InstSize&#x3D;%u ReadValue&#x3D;%016llX\n&quot;, __func__, Address, Operation, InstSize, ReadValue);&#125;else   &#x2F;&#x2F;不命中（读不命中）&#123;if (DEBUG)printf(&quot;[%s] Address&#x3D;%016llX Operation&#x3D;%c InstSize&#x3D;%u \n&quot;, __func__, Address, Operation, InstSize);MissFlag &#x3D; &#39;M&#39;;&#x2F;&#x2F; 不命中&#x2F;&#x2F; 需要从Memory中读入新的行（真实情况下，这个LoadCacheLineFromMemory需要很长时间的）LoadInstCacheLineFromMemory(Address, CacheLineAddress,AddressTag);    &#x2F;&#x2F;把一整行都读进去（不去考虑偏移量这个问题）&#125;return MissFlag;&#125;</code></pre><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://img-blog.csdnimg.cn/160383fca3914996a4651740a6c40e85.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化实验</title>
      <link href="/2022/04/09/xing-neng-you-hua-shi-yan/"/>
      <url>/2022/04/09/xing-neng-you-hua-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化实验"><a href="#性能优化实验" class="headerlink" title="性能优化实验"></a>性能优化实验</h1><p><em>以下代码只供参考，至于怎样展开，双重循环展开怎么搭配效果会更好，还是需要不断试验。</em></p><h2 id="实验一-poly-c的优化"><a href="#实验一-poly-c的优化" class="headerlink" title="实验一 poly.c的优化"></a>实验一 poly.c的优化</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><strong>1、常系数 const_poly_eval</strong>：不知道该怎么优化，感觉老师给的代码就很不错，直接套用。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int const_poly_eval(int *not_use, int not_use2, int x)&#123;&#x2F;&#x2F;int y &#x3D; x * x;&#x2F;&#x2F;int z &#x3D; y*x;    &#x2F;&#x2F;return 81 + (((y - z) + ((x &lt;&lt; 6) - (x &lt;&lt; 1))) + (((y &lt;&lt; 6) + (y &lt;&lt; 1)) + ((z &lt;&lt; 6) + (z &lt;&lt; 4))));int x64, x16, x2;x64 &#x3D; x &lt;&lt; 6;x16 &#x3D; x &lt;&lt; 4;x2 &#x3D; x &lt;&lt; 1;return 81 + x64 - x2 + (x64 + x2 + x + (x64 + x16 - x) * x) * x;&#125;</code></pre><p><strong>2、任意的高阶（和10阶） my_poly_eval</strong>：主要考虑循环展开，经过试验，当展开&gt;&#x3D;10时，几乎性能就达到最优了。同时需要单独考虑degree&#x3D;10的情况，为了让计算十阶更快一点，直接全部展开，并减少“昂贵”的乘法的使用。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int my_poly_eval(int *a, int degree, int x)&#123;if (degree &#x3D;&#x3D; 10) &#123;return a[0] + (a[1] + (a[2] + (a[3]+ (a[4]+ (a[5]+ (a[6]+ (a[7]+ (a[8]+ (a[9]+ a[10] * x)*x)*x)*x)*x)*x)*x)*x)*x)*x;&#x2F;&#x2F;return a[0] + a[1] * x + a[2] * xpwr2 + a[3] * xpwr3 + a[4] * xpwr4 + a[5] * xpwr5 + a[6] * xpwr6 + a[7] * xpwr7 + a[8] * xpwr8 + a[9] * xpwr9 + a[10] * xpwr10;&#125;else &#123;int i;&#x2F;&#x2F;int x2 &#x3D; x * x;&#x2F;&#x2F;int x5 &#x3D; x2 * x2 * x;&#x2F;&#x2F;int x11 &#x3D; x5 * x5 * x;int result &#x3D; 0;int xpwr2 &#x3D; x * x;int xpwr3 &#x3D; xpwr2 * x;int xpwr4 &#x3D; xpwr3 * x;int xpwr5 &#x3D; xpwr4 * x;int xpwr6 &#x3D; xpwr5 * x;int xpwr7 &#x3D; xpwr6 * x;int xpwr8 &#x3D; xpwr7 * x;int xpwr9 &#x3D; xpwr8 * x;int xpwr10 &#x3D; xpwr9 * x;int x11 &#x3D; xpwr10 * x;int limit11 &#x3D; degree - 11;int limit5 &#x3D; degree - 5;int cnt &#x3D; 1;for (i &#x3D; 0; i &lt;&#x3D; limit11; i +&#x3D; 11) &#123;result +&#x3D; (a[i] + a[i + 1]*x + a[i + 2] * xpwr2 + a[i + 3] * xpwr3 + a[i + 4] * xpwr4 + a[i + 5] * xpwr5 + a[i + 6] * xpwr6 + a[i + 7] * xpwr7 + a[i + 8] * xpwr8 + a[i + 9] * xpwr9 + a[i + 10] * xpwr10) * cnt;&#x2F;&#x2F;result +&#x3D; (a[i] + (a[i + 1] + (a[i + 2] + (a[i + 3] + (a[i + 4] + (a[i + 5] + (a[i + 6] + (a[i + 7] + (a[i + 8] + (a[i + 9] + a[i + 10] * x) * x) * x) * x) * x) * x) * x) * x) * x) * x) * cnt;cnt *&#x3D; x11;&#125;for (;i &lt;&#x3D; limit5;i +&#x3D; 5) &#123;result +&#x3D; (a[i] + a[i + 1] * x + a[i + 2] * xpwr2 + a[i + 3] * xpwr3 + a[i + 4] * xpwr4) * cnt;&#x2F;&#x2F;result +&#x3D; (a[i] + (a[i + 1] + (a[i + 2] + (a[i + 3] + a[i + 4] * x)*x)*x)*x) * cnt;cnt *&#x3D; xpwr5;&#x2F;&#x2F;cnt *&#x3D; x5;&#125;for (;i &lt;&#x3D; degree;i++) &#123;result +&#x3D; a[i] * cnt;cnt *&#x3D; x;&#125;return result;&#125;&#125;</code></pre><h3 id="结果：（使用的lcc编译器）"><a href="#结果：（使用的lcc编译器）" class="headerlink" title="结果：（使用的lcc编译器）"></a>结果：（使用的lcc编译器）</h3><p><img src="https://img-blog.csdnimg.cn/3d9ec68a334a48caa80e136e037b95df.png"></p><h2 id="实验二-rowcol-c的优化"><a href="#实验二-rowcol-c的优化" class="headerlink" title="实验二 rowcol.c的优化"></a>实验二 rowcol.c的优化</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>1、列求和 my_c_sum</strong>：这个循环展开即可，经过试验，&gt;&#x3D;10时，性能达到最优，直接上代码</p><pre class="language-c++" data-language="c++"><code class="language-c++">void my_c_sum(matrix_t M, vector_t rowsum, vector_t colsum)&#123;int i, j, limitj, limiti;for (i &#x3D; 0;i &lt; N;i++) &#123;colsum[i] &#x3D; 0;&#125;limitj &#x3D; N - 11;      &#x2F;&#x2F;两个实验，经过多次试验发现，展开&gt;&#x3D;10即可达到最高limiti &#x3D; N - 7;for (i &#x3D; 0; i &lt;&#x3D; limiti; i +&#x3D; 7) &#123;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];colsum[j + 1] +&#x3D; M[i][j + 1] + M[i + 1][j + 1] + M[i + 2][j + 1] + M[i + 3][j + 1] + M[i + 4][j + 1] + M[i + 5][j + 1] + M[i + 6][j + 1];&#x2F;&#x2F; + M[i + 7][j+1] + M[i + 8][j+1] + M[i + 9][j+1] + M[i + 10][j+1];colsum[j + 2] +&#x3D; M[i][j + 2] + M[i + 1][j + 2] + M[i + 2][j + 2] + M[i + 3][j + 2] + M[i + 4][j + 2] + M[i + 5][j + 2] + M[i + 6][j + 2];&#x2F;&#x2F; + M[i + 7][j+2] + M[i + 8][j+2] + M[i + 9][j+2] + M[i + 10][j+2];colsum[j + 3] +&#x3D; M[i][j + 3] + M[i + 1][j + 3] + M[i + 2][j + 3] + M[i + 3][j + 3] + M[i + 4][j + 3] + M[i + 5][j + 3] + M[i + 6][j + 3];&#x2F;&#x2F; + M[i + 7][j+3] + M[i + 8][j+3] + M[i + 9][j+3] + M[i + 10][j+3];colsum[j + 4] +&#x3D; M[i][j + 4] + M[i + 1][j + 4] + M[i + 2][j + 4] + M[i + 3][j + 4] + M[i + 4][j + 4] + M[i + 5][j + 4] + M[i + 6][j + 4];&#x2F;&#x2F; + M[i + 7][j+4] + M[i + 8][j+4] + M[i + 9][j+4] + M[i + 10][j+4];colsum[j + 5] +&#x3D; M[i][j + 5] + M[i + 1][j + 5] + M[i + 2][j + 5] + M[i + 3][j + 5] + M[i + 4][j + 5] + M[i + 5][j + 5] + M[i + 6][j + 5];&#x2F;&#x2F; + M[i + 7][j+5] + M[i + 8][j+5] + M[i + 9][j+5] + M[i + 10][j+5];colsum[j + 6] +&#x3D; M[i][j + 6] + M[i + 1][j + 6] + M[i + 2][j + 6] + M[i + 3][j + 6] + M[i + 4][j + 6] + M[i + 5][j + 6] + M[i + 6][j + 6];&#x2F;&#x2F; + M[i + 7][j+6] + M[i + 8][j+6] + M[i + 9][j+6] + M[i + 10][j+6];colsum[j + 7] +&#x3D; M[i][j + 7] + M[i + 1][j + 7] + M[i + 2][j + 7] + M[i + 3][j + 7] + M[i + 4][j + 7] + M[i + 5][j + 7] + M[i + 6][j + 7];&#x2F;&#x2F; + M[i + 7][j + 7] + M[i + 8][j + 7] + M[i + 9][j + 7] + M[i + 10][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8] + M[i + 1][j + 8] + M[i + 2][j + 8] + M[i + 3][j + 8] + M[i + 4][j + 8] + M[i + 5][j + 8] + M[i + 6][j + 8];&#x2F;&#x2F; + M[i + 7][j + 8] + M[i + 8][j + 8] + M[i + 9][j + 8] + M[i + 10][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9] + M[i + 1][j + 9] + M[i + 2][j + 9] + M[i + 3][j + 9] + M[i + 4][j + 9] + M[i + 5][j + 9] + M[i + 6][j + 9];&#x2F;&#x2F; + M[i + 7][j + 9] + M[i + 8][j + 9] + M[i + 9][j + 9] + M[i + 10][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10] + M[i + 1][j + 10] + M[i + 2][j + 10] + M[i + 3][j + 10] + M[i + 4][j + 10] + M[i + 5][j + 10] + M[i + 6][j + 10];&#x2F;&#x2F; + M[i + 7][j + 10] + M[i + 8][j + 10] + M[i + 9][j + 10] + M[i + 10][j + 10];&#125;for (;j &lt; N;j++) &#123;colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];&#125;&#125;for (;i &lt; N;i++) &#123;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;colsum[j] +&#x3D; M[i][j];colsum[j + 1] +&#x3D; M[i][j + 1];colsum[j + 2] +&#x3D; M[i][j + 2];colsum[j + 3] +&#x3D; M[i][j + 3];colsum[j + 4] +&#x3D; M[i][j + 4];colsum[j + 5] +&#x3D; M[i][j + 5];colsum[j + 6] +&#x3D; M[i][j + 6];colsum[j + 7] +&#x3D; M[i][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10];&#125;for (;j &lt; N;j++) &#123;colsum[j] +&#x3D; M[i][j];&#125;&#125;&#125;</code></pre><p><strong>2、行和列求和 my_rc_sum</strong>：这里我采用双重循环展开，但是至于怎么搭配会是最好我不太清楚，这里这是简单做了一些尝试，然后选取了7和11。另外，rowsum这里，我可以采用用一个临时变量来存储值，最后再让<code>rowsum[i] = yyhi</code>，这样减少了内存的调用，更快一点。</p><pre class="language-c++" data-language="c++"><code class="language-c++">void my_rc_sum(matrix_t M, vector_t rowsum, vector_t colsum)&#123;int i, j, limitj, limiti;int yyh0, yyh1, yyh2, yyh3, yyh4, yyh5, yyh6, yyh;for (i &#x3D; 0;i &lt; N;i++) &#123;colsum[i] &#x3D; 0;&#125;limitj &#x3D; N - 11;      &#x2F;&#x2F;经过多次试验发现，展开&gt;&#x3D;10即可达到最高limiti &#x3D; N - 7;for (i &#x3D; 0; i &lt;&#x3D; limiti; i +&#x3D; 7) &#123;yyh0 &#x3D; 0;yyh1 &#x3D; 0;yyh2 &#x3D; 0;yyh3 &#x3D; 0;yyh4 &#x3D; 0;yyh5 &#x3D; 0;yyh6 &#x3D; 0;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;yyh0 +&#x3D; M[i][j] + M[i][j + 1] + M[i][j + 2] + M[i][j + 3] + M[i][j + 4] + M[i][j + 5] + M[i][j + 6] + M[i][j + 7] + M[i][j + 8] + M[i][j + 9] + M[i][j + 10];yyh1 +&#x3D; M[i + 1][j] + M[i + 1][j + 1] + M[i + 1][j + 2] + M[i + 1][j + 3] + M[i + 1][j + 4] + M[i + 1][j + 5] + M[i + 1][j + 6] + M[i + 1][j + 7] + M[i + 1][j + 8] + M[i + 1][j + 9] + M[i + 1][j + 10];yyh2 +&#x3D; M[i + 2][j] + M[i + 2][j + 1] + M[i + 2][j + 2] + M[i + 2][j + 3] + M[i + 2][j + 4] + M[i + 2][j + 5] + M[i + 2][j + 6] + M[i + 2][j + 7] + M[i + 2][j + 8] + M[i + 2][j + 9] + M[i + 2][j + 10];yyh3 +&#x3D; M[i + 3][j] + M[i + 3][j + 1] + M[i + 3][j + 2] + M[i + 3][j + 3] + M[i + 3][j + 4] + M[i + 3][j + 5] + M[i + 3][j + 6] + M[i + 3][j + 7] + M[i + 3][j + 8] + M[i + 3][j + 9] + M[i + 3][j + 10];yyh4 +&#x3D; M[i + 4][j] + M[i + 4][j + 1] + M[i + 4][j + 2] + M[i + 4][j + 3] + M[i + 4][j + 4] + M[i + 4][j + 5] + M[i + 4][j + 6] + M[i + 4][j + 7] + M[i + 4][j + 8] + M[i + 4][j + 9] + M[i + 4][j + 10];yyh5 +&#x3D; M[i + 5][j] + M[i + 5][j + 1] + M[i + 5][j + 2] + M[i + 5][j + 3] + M[i + 5][j + 4] + M[i + 5][j + 5] + M[i + 5][j + 6] + M[i + 5][j + 7] + M[i + 5][j + 8] + M[i + 5][j + 9] + M[i + 5][j + 10];yyh6 +&#x3D; M[i + 6][j] + M[i + 6][j + 1] + M[i + 6][j + 2] + M[i + 6][j + 3] + M[i + 6][j + 4] + M[i + 6][j + 5] + M[i + 6][j + 6] + M[i + 6][j + 7] + M[i + 6][j + 8] + M[i + 6][j + 9] + M[i + 6][j + 10];colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];colsum[j + 1] +&#x3D; M[i][j + 1] + M[i + 1][j + 1] + M[i + 2][j + 1] + M[i + 3][j + 1] + M[i + 4][j + 1] + M[i + 5][j + 1] + M[i + 6][j + 1];&#x2F;&#x2F; + M[i + 7][j+1] + M[i + 8][j+1] + M[i + 9][j+1] + M[i + 10][j+1];colsum[j + 2] +&#x3D; M[i][j + 2] + M[i + 1][j + 2] + M[i + 2][j + 2] + M[i + 3][j + 2] + M[i + 4][j + 2] + M[i + 5][j + 2] + M[i + 6][j + 2];&#x2F;&#x2F; + M[i + 7][j+2] + M[i + 8][j+2] + M[i + 9][j+2] + M[i + 10][j+2];colsum[j + 3] +&#x3D; M[i][j + 3] + M[i + 1][j + 3] + M[i + 2][j + 3] + M[i + 3][j + 3] + M[i + 4][j + 3] + M[i + 5][j + 3] + M[i + 6][j + 3];&#x2F;&#x2F; + M[i + 7][j+3] + M[i + 8][j+3] + M[i + 9][j+3] + M[i + 10][j+3];colsum[j + 4] +&#x3D; M[i][j + 4] + M[i + 1][j + 4] + M[i + 2][j + 4] + M[i + 3][j + 4] + M[i + 4][j + 4] + M[i + 5][j + 4] + M[i + 6][j + 4];&#x2F;&#x2F; + M[i + 7][j+4] + M[i + 8][j+4] + M[i + 9][j+4] + M[i + 10][j+4];colsum[j + 5] +&#x3D; M[i][j + 5] + M[i + 1][j + 5] + M[i + 2][j + 5] + M[i + 3][j + 5] + M[i + 4][j + 5] + M[i + 5][j + 5] + M[i + 6][j + 5];&#x2F;&#x2F; + M[i + 7][j+5] + M[i + 8][j+5] + M[i + 9][j+5] + M[i + 10][j+5];colsum[j + 6] +&#x3D; M[i][j + 6] + M[i + 1][j + 6] + M[i + 2][j + 6] + M[i + 3][j + 6] + M[i + 4][j + 6] + M[i + 5][j + 6] + M[i + 6][j + 6];&#x2F;&#x2F; + M[i + 7][j+6] + M[i + 8][j+6] + M[i + 9][j+6] + M[i + 10][j+6];colsum[j + 7] +&#x3D; M[i][j + 7] + M[i + 1][j + 7] + M[i + 2][j + 7] + M[i + 3][j + 7] + M[i + 4][j + 7] + M[i + 5][j + 7] + M[i + 6][j + 7];&#x2F;&#x2F; + M[i + 7][j + 7] + M[i + 8][j + 7] + M[i + 9][j + 7] + M[i + 10][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8] + M[i + 1][j + 8] + M[i + 2][j + 8] + M[i + 3][j + 8] + M[i + 4][j + 8] + M[i + 5][j + 8] + M[i + 6][j + 8];&#x2F;&#x2F; + M[i + 7][j + 8] + M[i + 8][j + 8] + M[i + 9][j + 8] + M[i + 10][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9] + M[i + 1][j + 9] + M[i + 2][j + 9] + M[i + 3][j + 9] + M[i + 4][j + 9] + M[i + 5][j + 9] + M[i + 6][j + 9];&#x2F;&#x2F; + M[i + 7][j + 9] + M[i + 8][j + 9] + M[i + 9][j + 9] + M[i + 10][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10] + M[i + 1][j + 10] + M[i + 2][j + 10] + M[i + 3][j + 10] + M[i + 4][j + 10] + M[i + 5][j + 10] + M[i + 6][j + 10];&#x2F;&#x2F; + M[i + 7][j + 10] + M[i + 8][j + 10] + M[i + 9][j + 10] + M[i + 10][j + 10];&#125;for (;j &lt; N;j++) &#123;yyh0 +&#x3D; M[i][j];yyh1 +&#x3D; M[i + 1][j];yyh2 +&#x3D; M[i + 2][j];yyh3 +&#x3D; M[i + 3][j];yyh4 +&#x3D; M[i + 4][j];yyh5 +&#x3D; M[i + 5][j];yyh6 +&#x3D; M[i + 6][j];colsum[j] +&#x3D; M[i][j] + M[i + 1][j] + M[i + 2][j] + M[i + 3][j] + M[i + 4][j] + M[i + 5][j] + M[i + 6][j];&#x2F;&#x2F; + M[i + 7][j] + M[i + 8][j] + M[i + 9][j] + M[i + 10][j];&#125;rowsum[i] &#x3D; yyh0;rowsum[i + 1] &#x3D; yyh1;rowsum[i + 2] &#x3D; yyh2;rowsum[i + 3] &#x3D; yyh3;rowsum[i + 4] &#x3D; yyh4;rowsum[i + 5] &#x3D; yyh5;rowsum[i + 6] &#x3D; yyh6;&#125;for (;i &lt; N;i++) &#123;yyh &#x3D; 0;for (j &#x3D; 0; j &lt;&#x3D; limitj; j +&#x3D; 11) &#123;yyh +&#x3D; M[i][j] + M[i][j + 1] + M[i][j + 2] + M[i][j + 3] + M[i][j + 4] + M[i][j + 5] + M[i][j + 6] + M[i][j + 7] + M[i][j + 8] + M[i][j + 9] + M[i][j + 10];colsum[j] +&#x3D; M[i][j];colsum[j + 1] +&#x3D; M[i][j + 1];colsum[j + 2] +&#x3D; M[i][j + 2];colsum[j + 3] +&#x3D; M[i][j + 3];colsum[j + 4] +&#x3D; M[i][j + 4];colsum[j + 5] +&#x3D; M[i][j + 5];colsum[j + 6] +&#x3D; M[i][j + 6];colsum[j + 7] +&#x3D; M[i][j + 7];colsum[j + 8] +&#x3D; M[i][j + 8];colsum[j + 9] +&#x3D; M[i][j + 9];colsum[j + 10] +&#x3D; M[i][j + 10];&#125;for (;j &lt; N;j++) &#123;yyh +&#x3D; M[i][j];colsum[j] +&#x3D; M[i][j];&#125;rowsum[i] &#x3D; yyh;&#125;&#125;</code></pre><h3 id="结果：（使用的lcc编译器）-1"><a href="#结果：（使用的lcc编译器）-1" class="headerlink" title="结果：（使用的lcc编译器）"></a>结果：（使用的lcc编译器）</h3><p><img src="https://img-blog.csdnimg.cn/916e6726a64b4d0db990eb0cad339146.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo初体验</title>
      <link href="/2022/04/02/title1/"/>
      <url>/2022/04/02/title1/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建初体验"><a href="#Hexo搭建初体验" class="headerlink" title="Hexo搭建初体验"></a>Hexo搭建初体验</h1><p>yl告诉我一个小时就能搭完，结果从昨天上午到现在，我才搭建好框架。。。<br>只能说自己菜啊（QAQ），只是发篇文章试一下，我继续去搞背景和图床去了。<br>时隔29个小时，终于搞完了！！！！！<br>去赶ddl咯！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
